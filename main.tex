\documentclass[11pt]{report}

\input{estrutura.tex}

\begin{document}

\title{\includegraphics[width=0.5\textwidth]{minho.png}~\\[1cm] O Sistema Merkle-Hellman Knapsack}

\author{Bernardo Rodrigues\\ \texttt{a79008@alunos.uminho.pt}\\ \and César Silva\\ \texttt{a77518@alunos.uminho.pt}\\ \and Maria Francisca Fernandes\\ \texttt{a72450@alunos.uminho.pt}\\}

\date{Universidade do Minho --- \today}

\maketitle

\begin{abstract}

	Este documento apresenta os vários passos e considerações feitas para implementação do sistema em questão. Assim como, alguns factos relativos a este.  


\end{abstract}

\tableofcontents

\chapter{Introdução}

	Ao contrario do RSA nao da para fazer assinaturas criptograficas - wiki
1976 Diffie Hellman introduzem a ideia de criptografia de chave publica
Este trabalho foi desenvolvido no ambito da Unidade Curricular de \textit{Teoria de Números Computacional}. De entre as escolhas possiveis, foi escolhido estudar o sistema \textit{Merkle-Hellman Knapsack}. \\
Este foi um dos pioneiros da criptografia de chave pública, inventado por \textbf{Ralph Merkle} e por \textbf{Martin Hellman} em 1978.
A ideia por detrás deste sistema é mais simples do que a de sistemas como o \textit{RSA}, assentando no problema  (tendo já sido quebrado -- meter isto noutro sitio??).

\chapter{Implementação}

Ao longo das secções deste capítulo apresentamos os vários algoritmos seguidos para a codificação do sistema.

\section{Geração de Permutações}

Um dos passos da Geração da Chave Pública(criar ref) consiste em gerar uma permutação de uma sequência. Para tal utilizamos o algoritmo proposto por \textbf{Sandra Sattolo}. Este itera uma lista - $seq$ - a partir do ultimo índice desta - $n$. Em cada passo calculamos um índice aleatório - $j$ - tal que $1 \le j < n$ e de seguida trocamos os valores de $seq_j$ e $seq_n$ e (explicar resto). Continuamos assim até que $n = 1$.\\
A implementacão deste pode ser visualizada em criar ref.\\
O algoritmo pode ser visto aqui. criar ref.

\section{Geração de um sequência super crescente aleatória}

Um dos componentes da Chave Privada é uma sequência, esta é considerada super crescente se:\\
\begin{samepage}
	\begin{definition}
	Consideremos uma sequência de números ${b_1, ..., b_n}$. Esta diz-se super crescente se:
	\begin{center}
		$b_i > \sum_{j = 1}^{i - 1} b_j$ para cada $i$ tal que $2 \le i \le n$. 
	\end{center}
	\end{definition}
\end{samepage}
Como tal, conseguimos deduzir:

\begin{center}
	$b_1 + b_2 + ... + b_k < 2 \times b_k$
\end{center}
Ou seja, precisamos apenas de considerar o último valor gerado para calcular um possivel próximo.
Usaremos este facto para gerar a nossa sequência super crescente.\\
Com isto apresentamos o nosso algoritmo.
\begin{algorithm}
	\caption{Geração da sequência super crescente aleatória}
	\textbf{Recebe}: $n$ - o tamanho da sequência\\
	\textbf{Devolve}: $\{x_1, ..., x_n\}$ - uma sequência super crescente aleatória
	\begin{algorithmic}[1]
		\State $k$ um limite superior aleatóriamente grande
		\State $f$ uma funcão que satisfaz criar ref para a deducao 
		\State $x_1 \gets j$ tal que $1 \le j \le k$ aleatório
		\For{$x_i$ com $i:=2$ \textbf{até} $n$ }
			\State $x_i = f(x_{i-1})$
		\EndFor
\end{algorithmic}
\end{algorithm}

\section{Geração de Coprimos}

\section{Geração da Chave}

\subsection{Versão Multi-Iterada}

\section{Encriptacão}

\section{Decriptação}

\subsection{Versão Multi-Iterada}

\begin{algorithm}
	\caption{Solução da soma do subconjunto super crescente}
	\begin{algorithmic}[1]
		\State $i \gets n$
		\While{$i \ge 1 $}
			\If{$s \ge b_i $}
				\State $x_i \gets 1$
			\Else
				\State $x_i \gets 0 $
			\EndIf
		\State $i \gets i - 1$
		\EndWhile
\end{algorithmic}
\end{algorithm}


\chapter{Conclusões}

O RSA é melhor, passados 4 anos da sua cricao o Knapsack foi quebrado.
Falar em quebrar uma mensagem em pedaços?? 
Criticar : facil de quebrar.
Trabalho futuro: implementacao de um quebra.

\appendix

\chapter{Código??}

Será que vai num ficheiro separadamente?

\end{document}
